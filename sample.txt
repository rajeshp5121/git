cluster_endpoint=$(aws eks describe-cluster \
    --region $region_code \
    --name $cluster_name \
    --query "cluster.endpoint" \
    --output text)
	
	aws eks update-kubeconfig --region us-east-1 --name eks-cluster
	Updated context arn:aws:eks:us-east-1:804465342881:cluster/eks-cluster in /home/ubuntu/.kube/config
	
	aws eks update-kubeconfig --region region-code --name my-cluster
	
	
	aws eks update-kubeconfig --name my-cluster --region us-east-1
	
	eksctl create cluster --name my-cluster --region us-east-1
	
	arn:aws:eks:us-east-1:804465342881:cluster/eks-cluster
	aws eks update-kubeconfig --name eks-cluster --region us-east-1 --role-arn arn:aws:iam::804465342881:role/eksrole
	
	
	
	aws cloudformation create-stack \
  --region region-code \
  --stack-name my-eks-vpc-stack \
  --template-url https://s3.us-west-2.amazonaws.com/amazon-eks/cloudformation/2020-10-29/amazon-eks-vpc-private-subnets.yaml
  
  
  2213118952
  
  2213117387
  
  %SystemRoot%\system32;
  %SystemRoot%;%SystemRoot%\System32\Wbem;
  %SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;
  C:\Program Files\Java\jdk-11.0.3\bin;
  D:\KHANNA\IT\DEVOPS\MAVEN\apache-maven-3.8.4\bin;
  C:\Program Files\Git\cmd;C:\Program Files\PuTTY\;
  D:\KHANNA\IT\DEVOPS\TerraForm;C:\Program Files\Amazon\AWSCLI\bin\
  
  
  Docker Commands
--------------------
Working on Images
-------------------------
1 To download a docker image 
   docker pull image_name 



2 To see the list of docker images 
  docker image ls 
  (or) 
  docker images 

3 To delete a docker image from docker host 
  docker rmi image_name/image_id 

4) To upload a docker image into docker hub 
   docker push image_name 

5) To tag an image 
docker tag   image_name   ipaddress_of_local_registry:5000/image_name 

6) To build an image from a customised container 
  docker   commit  container_name/container_id     new_image_name 

7) To create an image from docker file 
   docker build -t    new_image_name 

8) To search for a docker image 
   docker search image_name 

9)  To delete all images that are not attached to containers 
   docker system prune -a 



++++++++++++++++++++++++++++++++++++++++++++++







Working on containers
-----------------------------

10) To see the list of all running continers 
   docker  container  ls 



11) To see the list of running and stopped containers 
    docker   ps -a 



12) To start a container 
    docker  start  container_name/container_id 




13) To stop a running container 
    docker stop   container_name/container_id 

14) To restart a running container 
   docker restart container_name/container_id 
         To restart after 10 seconds 
   docker restart  -t  10  container_name/container_id 





15) To delete a stopped container 
    docker  rm  container_name/container_id




16) To delete a running container 
    docker  rm  -f  container_name/container id 






17) To stop all running containers 
    docker stop $(docker ps -aq) 



18) To restart all containers 
    docker restart $(docker ps -aq) 

19) To remove all stopped containers 
    docker rm $(docker ps -aq) 


20) To remove all contianers(running and stopped) 
    docker rm -f  $(docker ps -aq) 

21) To see the logs generated by a container 
   docker logs container_name/container_id 

22) To see the ports used by a container 
   docker port container_name/container_id 

23) To get detailed info about a container 
   docker inspect container_name/container_id 

24) To go into the shell of a running contianer which is moved into background 
   docker attach container_name/container id 

25) To execute anycommand in a container 
   docker exec -it container_name/container_id command
   Eg: To launch the bash shell in a contianer 
   docker exec -it container_name/container_id    bash 


26) To create a container from a docker image  ( imp )
     docker run image_name   

++++++++++++++++++++++++++++++++++++++++++++++++




Run command options 

-it 	for opening an interactive terminal in a container 


--name 	Used for giving a name to a container 

-d 	Used for running the container in detached mode as a background process 

-e 	Used for passing environment varaibles to the container 



-p 	Used for port mapping between port of container with the dockerhost port.

 
-P 	Used for automatic port mapping ie, it will map the internal port of the container 
                with some port on host machine. 
               This host port will be some number greater than 30000 

-v 	Used for attaching a volume to the container 

--volume-from 	 Used for sharing volume between containers 

--network 	Used to run the contianer on a specific network 
--link 		Used for linking the container for creating a multi container architecture 

--memory  	Used to specify the maximum amount of ram that the container can use 



******************************************************

$(dirname $(dirname $(readlink -f $(which javac))) )

/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64

sudo alternatives java 


 
#!/bin/bash
sudo su -
yum update -y
yum install httpd -y
cd /var/www/html
echo "MyGoogle-2" > index.html
service httpd start
chkconfig httpd on



git remote set-url origin https://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@github.com/rajeshp5121/git.git
https://github.com/rajeshp5121/git.git


docker exec devserver cat /var/jenkins_home/secrets/initialAdminPassword
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


https://s3.us-west-2.amazonaws.com/amazon-eks/cloudformation/2020-10-29/amazon-eks-vpc-private-subnets.yaml



SecurityGroups	sg-0d3a7a87f888337f7	
SubnetIds	    subnet-0b829958aa47753d2,
				subnet-03bce212abf9354ee,
				subnet-00cd00ff8638a87d3,
				subnet-038796aff87a8fb32	
				
VpcId	  		vpc-0fd4c851435a731a5

adhoc commands
----------------

Important modules in ansible
1) command - This module is used for executing basic linux commands on managed nodes.
2) shell -  This module is used to execute commands which involved redirection and piping and to execute shell scripts on managed nodes.
3) ping  --  This module is used to check if the remote server is pingable or not.
4) user --  This module is used for user management like create user, setting password, assign home directory  etc

5) copy  --  This module is used to copy the files and folders from controller to managed nodes


6) fetch  --  This module is used to copy files and folder from managed nodes to controller

7) file  --  This module is used for creating or deleting files and folders on managed nodes.

8) stat  --  Used to capture detailed information about files and folders present in managed nodes.

9) debug --  Used to display output of any module

10) apt   --  Used for performing package management on managed nodes ie installing softwares / upgrading repositories  etc . It works on ubuntu, debain flavours of linux. 

11) yum  --  similar to apt module. It works on Red hat linux, centos etc


12) git  --  used to perform git version controlling on managed nodes

13) replace -- This is used to replace specific text in configuration file with some other text.


14) service  -- used for starting / stoping / restarting services on managed nodes.

15) include  --  Used for calling child play books  from parent play book

16) uri    -- useful in checking  if remote url is reachable or not.

17) docker_container  --  used to execute docker  commands related to container management on managed nodes

18) docker_image  --  used to execute commands related to docker images on managed nodes.

19) docker_login  --  used to login to docker hub from managed nodes.

20) setup   --  used to capturing system information related to the managed nodes.

++++++++++++++++++++++++++++++++++++++++++++++



$ ansible all -i /etc/ansible/hosts -m command -a 'free'




$ ansible all -i /etc/ansible/hosts -m command -a 'touch file1'
Jenkinsfile

node('master/built-in') 
{
    stage('Continuous Download') 
	{
    git 'https://github.com/sunildevops77/maven.git'
	}
    stage('Continuous Build') 
	{
    sh label: '', script: 'mvn package'
	}
    stage('Continuous Deployment') 
	{
    sh label: '', script: 'scp /home/ubuntu/.jenkins/workspace/ScriptedPipeline/webapp/target/webapp.war  
								ubuntu@172.31.26.217:/var/lib/tomcat8/webapps/qaenv.war'
	}
    stage('Continuous Testing') 
	{
              sh label: '', script: 'echo "Testing Passed"'
	}
    stage('Continuous Delivery') 
	{
	sh label: '', script: 'scp /home/ubuntu/.jenkins/workspace/ScriptedPipeline/webapp/target/webapp.war  
							ubuntu@172.31.22.88:/var/lib/tomcat8/webapps/prodenv.war'
	}
}




$(dirname $(dirname $(readlink -f $(which javac))) )

/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.amzn2.0.2.x86_64

sudo alternatives java 


 
#!/bin/bash
sudo su
yum update -y
yum install httpd -y
cd /var/www/html
echo "MyGoogle-2" > index.html
service httpd start
chkconfig httpd on



git remote set-url origin https://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@github.com/rajeshp5121/devops.git
https://github.com/rajeshp5121/devops.git


docker exec devserver cat /var/jenkins_home/secrets/initialAdminPassword

apiVersion: v1
kind: Pod 
metadata:
 name: nginx 
labels: 
  app : nginx 
spec : 
containers: 
  - name: nginx
    image: nginx
    volumeMounts: 
      - name: www 
        mountPath: /etc/nginx/
		
		
		Canary Deployment
A canary deployment, or canary release,
 is a deployment pattern that allows you to roll out new code/features 
 to a subset of users as an initial test.

Implement Canary Releases
The initial steps for implementing canary deployment are:
 create two clones of the production environment, 
 have a load balancer that initially sends all traffic to one version,
 and creates new functionality in the other version. 
 When you deploy the new software version, you shift some percentage – say, 
 10% – of your user base to the new version while maintaining 90% of users on the old version.
 If that 10% reports no errors, you can roll it out to gradually more users, 
 until the new version is being used by everyone. If the 10% has problems, though,
 you can roll it right back, and 90% of your users will have never even seen the problem.

Note that infrastructure changes and configuration changes should always be
 tested with canaries because of their sensitivity.

Why Canary Deployment?
Canary deployment benefits include zero downtime,
 easy rollout and quick rollback – plus the added safety from the gradual rollout process.
 It also has some drawbacks – the expense of maintaining multiple server instances,
 the difficult clone-or-don’t-clone database decision.

Typically, software development teams implement blue/green deployment 
when they’re sure the new version will work properly and want a simple, fast strategy to deploy it. 
Conversely, canary deployment is most useful when the development team isn’t as sure about
 the new version and they don’t mind a slower rollout if it means they’ll be able to catch the bugs.

Where Did the Canary Deployment Concept Come From?
You might be wondering why a little yellow bird is used to indicate a test release of a new feature. 
To answer that, we’ll have to go back to the coal mining days of the 1920s. 
Miners brought caged canaries into the coal mines because
 if there was a high level of toxic gases (typically carbon monoxide),
 the canary would die, alerting the miners to evacuate the tunnel immediately.

In a similar vein, when you release a feature to a small subset of users, 
those users can act as the canary, providing an early warning 
if something goes wrong so that you can rollback to the previous, stable version of the application.

